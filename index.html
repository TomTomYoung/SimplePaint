<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Paint (UI fixed)</title>
<style>
  :root {
    --ui: 34px;            /* 最小高さ */
    --gap: 6px;
    --headerH: 48px;       /* JSで実高に更新 */
    font-synthesis-weight:none;
  }
  * { box-sizing: border-box; }
  html, body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans JP", sans-serif; overflow: hidden; }

  /* ← 固定高さをやめて自動高さ。折り返しやオーバーフローに強くする */
  header, footer {
    min-height: var(--ui);
    display: flex;
    align-items: center;
    gap: var(--gap);
    padding: 6px 8px;
    border-bottom: 1px solid #ddd;
    overflow: hidden;
  }
  footer { border-top: 1px solid #ddd; border-bottom: none; }

  /* ← グリッドの行高も auto に変更（以前は var(--ui) で固定だった） */
  #app { display: grid; grid-template-rows: auto 1fr auto; height: 100dvh; }

  #stage { position: relative; background: #f6f6f6; overflow: scroll; }
  canvas { position: absolute; inset: 0; image-rendering: pixelated; z-index: 0; }
  #overlay { pointer-events: none; z-index: 1; }

  /* ← エディタレイヤは transform 原点を左上に固定し、拡縮時のズレを防止 */
#editorLayer {
  position: absolute;
  inset: 0;
  pointer-events: none;  /* 編集時のみ JS で auto に */
  z-index: 2;
  transform-origin: 0 0; /* ← 原点固定でズレ/ぼけ防止 */
  will-change: transform;
}

  /* ← ツールバーは横スクロールで詰める。親headerは伸びない */
  #tools {
    display:flex;
    align-items:center;
    gap:var(--gap);
    flex-wrap:wrap;                        /* 2行に折り返し */
    white-space:normal;
    flex:1 1 auto;
    padding-bottom:2px;
    overflow:auto;                         /* ← autoでOK */
    min-width:0;                           /* ← これが肝 */
    scrollbar-gutter: stable both-edges;   /* ← 常時レール確保 */
  }
  #tools::-webkit-scrollbar{
    width:8px; height:8px;
    background:#f0f0f0;                    /* ← レールを常時描画 */
  }
  #tools::-webkit-scrollbar-thumb{
    background:#ccc; border-radius:4px;
  }
  
  #stage::-webkit-scrollbar { width: 8px; height: 8px; }
  #stage::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }

  button, select, input[type="color"], input[type="number"] { height: 28px; }
  .tool { padding: 4px 8px; flex: none; }
  .row { display:flex; align-items:center; gap: var(--gap); }
  .sep { width:1px; height:22px; background:#e2e2e2; margin:0 4px; }
  #status { font-size: 12px; color:#555; }
  .active { outline: 2px solid #4a90e2; }

  /* 調整パネルをヘッダの実高に追従。 z-indexで最前面へ */
  #adjustPanel {
    position: fixed;
    right: 12px;
    top: calc(var(--headerH) + 8px);
    width: 280px;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0,0,0,.12);
    padding: 10px;
    display: none;
    z-index: 999;  /* ← いちばん上 */
  }
  #adjustPanel h3 { margin: 4px 0 8px; font-size: 14px; }
  #adjustPanel .row { justify-content: space-between; }
  #adjustPanel label { font-size: 12px; color: #333; }
  #adjustPanel input[type="range"] { width: 160px; height: 20px; }
  #adjustPanel .actions { display:flex; gap:8px; justify-content:flex-end; margin-top: 8px; }

  #fileInput { display:none; }
  .badge { font-size:12px; padding:2px 6px; border:1px solid #ddd; border-radius:4px; }

/* 必須: テキスト編集ボックスの見た目と配置 */
.text-editor{
  position:absolute;          /* ← これが無いと left/top が効かない */
  min-width:40px; min-height:24px;
  padding:4px 6px;
  outline:1px dashed #4a90e2;
  background:transparent;
  white-space:pre-wrap;
  color:#000;
  font: 16px/1.4 system-ui, sans-serif; /* 初期フォント */
  pointer-events:auto; user-select:text;
}


</style>
</head>
<body>
<div id="app">
  <header>
    <div id="tools" class="row">
      <button class="tool" data-tool="selectRect" title="M">選択</button>
      <div class="sep"></div>
      <button class="tool" data-tool="pencil" title="P">鉛筆</button>
      <button class="tool" data-tool="eraser" title="E">消しゴム</button>
      <button class="tool" data-tool="eyedropper" title="I">スポイト</button>
      <button class="tool" data-tool="bucket" title="F">バケツ</button>
      <div class="sep"></div>
      <button class="tool" data-tool="line" title="L">直線</button>
      <button class="tool" data-tool="rect" title="R">矩形</button>
      <button class="tool" data-tool="ellipse" title="O">楕円</button>
      <button class="tool" data-tool="quad" title="Q">2次ベジェ</button>
      <button class="tool" data-tool="cubic" title="C">3次ベジェ</button>
      <button class="tool" data-tool="arc" title="A">円弧</button>
      <button class="tool" data-tool="sector" title="S">扇形</button>
      <button class="tool" data-tool="catmull" title="U">Catmull</button>
      <button class="tool" data-tool="bspline" title="B">Bスプライン</button>
      <button class="tool" data-tool="nurbs" title="N">NURBS</button>
      <button class="tool" data-tool="ellipse2" title="E">楕円(回転)</button>
      <button class="tool" data-tool="freehand" title="H">補間描画</button>
      <label class="row badge">塗り <input id="fillOn" type="checkbox" checked></label>
      <label class="row badge">AA <input id="antialias" type="checkbox"></label>
      <div class="sep"></div>
      <button class="tool" data-tool="text" title="T">テキスト</button>
      <select id="fontFamily">
        <option value='system-ui, sans-serif'>System</option>
        <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
        <option value='serif'>Serif</option>
        <option value='monospace'>Monospace</option>
      </select>
      <input id="fontSize" type="number" min="8" max="200" value="24" style="width:64px">
      <div class="sep"></div>
      線幅 <input id="brush" type="range" min="1" max="64" value="4" />
      <div class="sep"></div>
      線色 <input id="color" type="color" value="#000000" />
      塗色 <input id="color2" type="color" value="#ffffff" />
      <div class="sep"></div>
      <button id="undo">Undo</button>
      <button id="redo">Redo</button>
      <button id="clear">全消去</button>
      <div class="sep"></div>
      <button id="open">開く</button><input id="fileInput" type="file" accept="image/*">
      <button id="savePNG">保存 PNG</button>
      <button id="saveJPG">保存 JPEG</button>
      <button id="saveWEBP">保存 WebP</button>
      <div class="sep"></div>
      <button id="copyBtn" title="Ctrl+C">コピー</button>
      <button id="cutBtn" title="Ctrl+X">カット</button>
      <button id="pasteBtn" title="Ctrl+V">ペースト</button>
      <div class="sep"></div>
      <button id="adjustBtn">調整</button>
      <div class="sep"></div>
      <button id="fit">画面に合わせる</button>
      <button id="actual">100%</button>

      <div class="row" style="margin-left:auto; gap:12px;">
        <span id="autosaveBadge" style="white-space:nowrap;">AutoSave: —</span>
        <span style="white-space:nowrap;">ズーム: <span id="zoomPct">100%</span></span>
      </div>
    </div>
  </header>

  <div id="stage">
    <canvas id="base"></canvas>
    <canvas id="overlay"></canvas>
    <div id="editorLayer"></div>
  </div>

  <footer class="row">
    <div id="status">準備完了</div>
    <div class="row" style="margin-left:auto">
      Space+ドラッグ=パン / Ctrl+ホイール=ズーム / 中ボタン=パン / Shift=拘束 / Esc=解除
    </div>
  </footer>
</div>

<!-- 調整パネル（中身は前回と同じ） -->
<div id="adjustPanel" role="dialog" aria-label="調整">
  <h3>調整（選択があれば選択範囲に適用）</h3>
  <div class="row"><label>明るさ</label><input id="adjBrightness" type="range" min="-100" max="100" value="0"></div>
  <div class="row"><label>コントラスト</label><input id="adjContrast" type="range" min="-100" max="100" value="0"></div>
  <div class="row"><label>彩度</label><input id="adjSaturation" type="range" min="-100" max="100" value="0"></div>
  <div class="row"><label>色相</label><input id="adjHue" type="range" min="-180" max="180" value="0"></div>
  <div class="row"><label>反転</label><input id="adjInvert" type="checkbox"></div>
  <div class="actions">
    <button id="adjReset">リセット</button>
    <button id="adjCancel">キャンセル</button>
    <button id="adjApply">適用</button>
  </div>
</div>

<script type="module">
/* ===== helpers ===== */
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
const dpr=()=>window.devicePixelRatio||1;
const toHex=(r,g,b)=>'#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
const nowFmt=()=>new Date().toLocaleTimeString();

/* ===== DOM ===== */
const base=document.getElementById('base');
const overlay=document.getElementById('overlay');
const editorLayer=document.getElementById('editorLayer');
const stage=document.getElementById('stage');
const zoomEl=document.getElementById('zoomPct');
const statusEl=document.getElementById('status');
const autosaveBadge=document.getElementById('autosaveBadge');

const headerEl = document.querySelector('header');
function syncHeaderHeight(){
  if (!headerEl) return;
  const h = Math.ceil(headerEl.getBoundingClientRect().height);
  document.documentElement.style.setProperty('--headerH', h + 'px');
}

function centerStageScroll(){
  stage.scrollLeft = (stage.scrollWidth - stage.clientWidth) / 2;
  stage.scrollTop = (stage.scrollHeight - stage.clientHeight) / 2;
}
new ResizeObserver(() => syncHeaderHeight()).observe(headerEl);
window.addEventListener('load', syncHeaderHeight);
window.addEventListener('resize', syncHeaderHeight);
window.addEventListener('load', centerStageScroll);
window.addEventListener('resize', centerStageScroll);

// 追加：エディタ外クリックでテキスト確定（先に走らせるため capture:true）
document.addEventListener('pointerdown', (e) => {
  if (activeEditor && !(e.target && e.target.closest && e.target.closest('.text-editor'))) {
    cancelTextEditing(true);
    engine.requestRepaint();
  }
}, { capture: true });

/* ===== work bitmap ===== */
const bmp=document.createElement('canvas');
const bctx=bmp.getContext('2d',{willReadFrequently:true});

/* ===== display resize ===== */
function resizeCanvasToDisplaySize(canvas, cssW, cssH){
  const ratio=dpr(); const w=Math.floor(cssW*ratio), h=Math.floor(cssH*ratio);
  if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; }
}

/* ===== store ===== */
function createStore(initial){ let state={...initial}; const subs=new Set();
  return { getState:()=>state, set(p){ state={...state,...p}; subs.forEach(f=>f(state)); }, subscribe(f){ subs.add(f); return ()=>subs.delete(f); } };
}

/* ===== viewport ===== */
class Viewport{ constructor(){ this.zoom=1; this.panX=0; this.panY=0; }
  screenToImage(x,y){ return {x:(x-this.panX)/this.zoom, y:(y-this.panY)/this.zoom}; }
  imageToScreen(x,y){ return {x:x*this.zoom+this.panX, y:y*this.zoom+this.panY}; } }

/* ===== history ===== */
class History{ constructor(){ this.stack=[]; this.index=-1; }
  pushPatch(p){ this.stack.length=this.index+1; this.stack.push(p); this.index++; }
  undo(){ if(this.index<0) return null; return this.stack[this.index--]; }
  redo(){ if(this.index>=this.stack.length-1) return null; return this.stack[++this.index]; } }

/* ===== engine ===== */
class Engine{
  constructor(store,vp){
    this.store=store; this.vp=vp; this.ctx=bctx; this.history=new History();
    this.tools=new Map(); this.current=null;
    this.selection=null; this._antsPhase=0;
    this._preStrokeCanvas=null; this._pendingRect=null;
    this.filterPreview=null; // {canvas, x, y}
    this._bindEvents(); this.requestRepaint=this.requestRepaint.bind(this);
    const tick=()=>{ this._antsPhase=(this._antsPhase+1)%16; this.requestRepaint(); requestAnimationFrame(tick); };
    requestAnimationFrame(tick);
  }
  setTool(id){ this.current=this.tools.get(id); base.style.cursor=this.current?.cursor||'default'; }
  register(t){ this.tools.set(t.id,t); }
  clearSelection(){ this.selection=null; this.current && (this.current.previewRect=null); }
  pointInRect(p,r){ return p.x>=r.x&&p.y>=r.y&&p.x<r.x+r.w&&p.y<r.y+r.h; }

  beginStrokeSnapshot(){ this._preStrokeCanvas=document.createElement('canvas'); this._preStrokeCanvas.width=bmp.width; this._preStrokeCanvas.height=bmp.height; this._preStrokeCanvas.getContext('2d').drawImage(bmp,0,0); this._pendingRect=null; }
  expandPendingRectByRect(x,y,w,h){ const minX=Math.max(0,Math.floor(x)), minY=Math.max(0,Math.floor(y)), maxX=Math.min(bmp.width,Math.ceil(x+w)), maxY=Math.min(bmp.height,Math.ceil(y+h));
    if(!this._pendingRect) this._pendingRect={minX,minY,maxX,maxY}; else { this._pendingRect.minX=Math.min(this._pendingRect.minX,minX); this._pendingRect.minY=Math.min(this._pendingRect.minY,minY); this._pendingRect.maxX=Math.max(this._pendingRect.maxX,maxX); this._pendingRect.maxY=Math.max(this._pendingRect.maxY,maxY); } }
  expandPendingRect(x,y,r=1){ this.expandPendingRectByRect(x-r*2,y-r*2,r*4,r*4); }
  finishStrokeToHistory(){ if(!this._preStrokeCanvas||!this._pendingRect){ this._preStrokeCanvas=null; this._pendingRect=null; return; }
    const rect={ x:this._pendingRect.minX, y:this._pendingRect.minY, w:Math.max(1,this._pendingRect.maxX-this._pendingRect.minX), h:Math.max(1,this._pendingRect.maxY-this._pendingRect.minY) };
    const pre=this._preStrokeCanvas.getContext('2d').getImageData(rect.x,rect.y,rect.w,rect.h);
    const aft=bctx.getImageData(rect.x,rect.y,rect.w,rect.h);
    this.history.pushPatch({rect,before:pre,after:aft});
    this._preStrokeCanvas=null; this._pendingRect=null;
  }

  requestRepaint(){
    const css=stage.getBoundingClientRect(); resizeCanvasToDisplaySize(base,css.width,css.height); resizeCanvasToDisplaySize(overlay,css.width,css.height);
    const ratio=dpr(); const ctx=base.getContext('2d');
    const aa=this.store.getState().antialias;
    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,base.width,base.height);
    ctx.setTransform(ratio*this.vp.zoom,0,0,ratio*this.vp.zoom,ratio*this.vp.panX,ratio*this.vp.panY);
    ctx.imageSmoothingEnabled=aa; ctx.drawImage(bmp,0,0);

    const octx=overlay.getContext('2d'); octx.setTransform(1,0,0,1,0,0); octx.clearRect(0,0,overlay.width,overlay.height);
    octx.setTransform(ratio*this.vp.zoom,0,0,ratio*this.vp.zoom,ratio*this.vp.panX,ratio*this.vp.panY);
    octx.imageSmoothingEnabled=aa;
    const rendering=aa?'auto':'pixelated';
    base.style.imageRendering=rendering;
    overlay.style.imageRendering=rendering;

    // 調整プレビュー
    if(this.filterPreview){
      const {canvas,x,y}=this.filterPreview;
      octx.drawImage(canvas, x||0, y||0);
    }

    if(this.current && this.current.drawPreview){
      this.current.drawPreview(octx);
    }

    // 選択の蟻枠／フロート
    if(this.selection){
      const sel=this.selection;
      if(sel.floatCanvas){ octx.drawImage(sel.floatCanvas, sel.pos.x, sel.pos.y); }
      const r=this.current?.previewRect || sel.rect;
      if(r){ this.drawAnts(octx,r); }
    }
    // エディタDOMの変換
    editorLayer.style.transform=`translate(${this.vp.panX}px, ${this.vp.panY}px) scale(${this.vp.zoom})`;
    zoomEl.textContent=Math.round(this.vp.zoom*100)+'%';
  }
  drawAnts(octx,r){ octx.save(); octx.lineWidth=1; octx.strokeStyle='#000'; octx.setLineDash([6,4]); octx.lineDashOffset=-this._antsPhase; octx.strokeRect(r.x+0.5,r.y+0.5,r.w,r.h); octx.strokeStyle='#fff'; octx.lineDashOffset=6-this._antsPhase; octx.strokeRect(r.x+0.5,r.y+0.5,r.w,r.h); octx.restore(); }

  undo(){ const p=this.history.undo(); if(!p) return; bctx.putImageData(p.before,p.rect.x,p.rect.y); this.requestRepaint(); }
  redo(){ const p=this.history.redo(); if(!p) return; bctx.putImageData(p.after,p.rect.x,p.rect.y); this.requestRepaint(); }

  _bindEvents(){
    const pointer=(e)=>{ const r=base.getBoundingClientRect(); const sx=e.clientX-r.left, sy=e.clientY-r.top; const img=this.vp.screenToImage(sx,sy); return {sx,sy,img,shift:e.shiftKey}; };
    let isPanning=false,lastS=null,spaceDown=false;

stage.addEventListener('pointerdown', e=>{
  // テキストエディタ内クリックはキャンバス処理しない
  if (e.target && e.target.closest && e.target.closest('.text-editor')) return;

  const p = pointer(e);

  // ★ Textツールのときは Pointer Capture をしない（キャレット表示が安定）
  if (!(this.current && this.current.id === 'text')) {
    stage.setPointerCapture(e.pointerId);
  }

  // 中ボタン or Space でパン
  if (e.button===1 || spaceDown){ isPanning=true; lastS={x:e.clientX,y:e.clientY}; return; }

  // 左ボタン：ツール処理
  if (e.button===0){
    this.beginStrokeSnapshot();
    this.current?.onPointerDown(this.ctx,p,this);
    this.requestRepaint();
  }
});


    stage.addEventListener('pointermove', e=>{
      const p=pointer(e);
      if(isPanning&&lastS){ const dx=e.clientX-lastS.x, dy=e.clientY-lastS.y; this.vp.panX+=dx; this.vp.panY+=dy; lastS={x:e.clientX,y:e.clientY}; this.requestRepaint(); updateStatus(p); return; }
      this.current?.onPointerMove(this.ctx,p,this); this.requestRepaint(); updateStatus(p);
    });
    stage.addEventListener('pointerup', e=>{
      if(isPanning){ isPanning=false; return; }
      const p=pointer(e); this.current?.onPointerUp(this.ctx,p,this); this.finishStrokeToHistory(); this.requestRepaint();
    });
    stage.addEventListener('wheel', e=>{
      if(!(e.ctrlKey||e.metaKey)) return; e.preventDefault();
      const rect=base.getBoundingClientRect(); const sx=e.clientX-rect.left, sy=e.clientY-rect.top; const before=this.vp.screenToImage(sx,sy);
      const factor=e.deltaY>0?0.9:1.1; this.vp.zoom=clamp(this.vp.zoom*factor,0.1,32);
      const after=this.vp.imageToScreen(before.x,before.y); this.vp.panX+=(sx-after.x); this.vp.panY+=(sy-after.y); this.requestRepaint();
    },{passive:false});

window.addEventListener('keydown', e=>{
  // ★ テキスト編集中はショートカットを殺す（Escだけ通す）
  if (activeEditor) {
    if (e.code === 'Escape') { e.preventDefault(); cancelTextEditing(false); engine.requestRepaint(); }
    return; // ← P/T/Space/Undo など全部無効
  }

  if(e.code==='Space'){ e.preventDefault(); base.style.cursor='grab'; } // パン開始フラグはpointermove側で見る
  if((e.ctrlKey||e.metaKey)&&e.code==='KeyZ'){ e.preventDefault(); engine.undo(); }
  if((e.ctrlKey||e.metaKey)&&e.code==='KeyY'){ e.preventDefault(); engine.redo(); }
  if(e.code==='KeyP') selectTool('pencil');
  if(e.code==='KeyT') selectTool('text');
});

    window.addEventListener('keyup', e=>{ if(e.code==='Space'){ spaceDown=false; base.style.cursor=this.current?.cursor||'default'; } });

    // DnD open
    stage.addEventListener('dragover', e=>e.preventDefault());
    stage.addEventListener('drop', e=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(f) openImageFile(f); });
  }
}

/* ===== tools: pencil/eraser/eyedropper/bucket/shape/select/text ===== */
// (前回と同等。省略せず記述)
function makePencil(store){ let drawing=false,last=null; return {
  id:'pencil', cursor:'crosshair',
  onPointerDown(ctx,ev,eng){ eng.clearSelection(); drawing=true; last=ev.img; eng.expandPendingRect(ev.img.x,ev.img.y,store.getState().brushSize); stroke(ctx,ev.img,store); },
  onPointerMove(ctx,ev,eng){ if(!drawing) return; eng.expandPendingRect(ev.img.x,ev.img.y,store.getState().brushSize); stroke(ctx,ev.img,store); },
  onPointerUp(){ drawing=false; last=null; }
}; function stroke(ctx,img,store){ const s=store.getState(); ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle=s.primaryColor; ctx.lineWidth=s.brushSize; ctx.beginPath(); if(last) ctx.moveTo(last.x+0.01,last.y+0.01); else ctx.moveTo(img.x+0.01,img.y+0.01); ctx.lineTo(img.x+0.01,img.y+0.01); ctx.stroke(); ctx.restore(); last=img; } }
function makeEraser(store){ let drawing=false,last=null; return {
  id:'eraser', cursor:'cell',
  onPointerDown(ctx,ev,eng){ eng.clearSelection(); drawing=true; last=ev.img; eng.expandPendingRect(ev.img.x,ev.img.y,store.getState().brushSize); erase(ctx,ev.img,store); },
  onPointerMove(ctx,ev,eng){ if(!drawing) return; eng.expandPendingRect(ev.img.x,ev.img.y,store.getState().brushSize); erase(ctx,ev.img,store); },
  onPointerUp(){ drawing=false; last=null; }
}; function erase(ctx,img,store){ const s=store.getState(); ctx.save(); ctx.globalCompositeOperation='destination-out'; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='rgba(0,0,0,1)'; ctx.lineWidth=s.brushSize; ctx.beginPath(); if(last) ctx.moveTo(last.x+0.01,last.y+0.01); else ctx.moveTo(img.x+0.01,img.y+0.01); ctx.lineTo(img.x+0.01,img.y+0.01); ctx.stroke(); ctx.restore(); last=img; } }
function makeEyedropper(store){ return { id:'eyedropper', cursor:'copy', onPointerDown(ctx,ev){ const x=Math.floor(ev.img.x), y=Math.floor(ev.img.y); if(x<0||y<0||x>=bmp.width||y>=bmp.height) return; const {data}=bctx.getImageData(x,y,1,1); store.set({primaryColor: toHex(data[0],data[1],data[2])}); }, onPointerMove(){}, onPointerUp(){} }; }
function floodFillBctx(x0,y0,rgba,th=0){ if(x0<0||y0<0||x0>=bmp.width||y0>=bmp.height) return null; const img=bctx.getImageData(0,0,bmp.width,bmp.height), d=img.data, w=bmp.width, h=bmp.height, id=(x,y)=>(y*w+x)*4;
  const sr=d[id(x0,y0)],sg=d[id(x0,y0)+1],sb=d[id(x0,y0)+2],sa=d[id(x0,y0)+3]; const same=(r,g,b,a)=>Math.abs(r-sr)+Math.abs(g-sg)+Math.abs(b-sb)+Math.abs(a-sa)<=th; const [fr,fg,fb,fa]=rgba; if(same(fr,fg,fb,fa)&&th===0) return null; const st=[[x0,y0]]; let minx=x0,maxx=x0,miny=y0,maxy=y0;
  while(st.length){ let [x,y]=st.pop(); while(x>=0&&same(d[id(x,y)],d[id(x,y)+1],d[id(x,y)+2],d[id(x,y)+3])) x--; x++; let up=false,dn=false;
    while(x<w&&same(d[id(x,y)],d[id(x,y)+1],d[id(x,y)+2],d[id(x,y)+3])){ const i=id(x,y); d[i]=fr; d[i+1]=fg; d[i+2]=fb; d[i+3]=fa; minx=Math.min(minx,x); maxx=Math.max(maxx,x); miny=Math.min(miny,y); maxy=Math.max(maxy,y);
      if(y>0){ const iu=id(x,y-1); const su=same(d[iu],d[iu+1],d[iu+2],d[iu+3]); if(!up&&su){ st.push([x,y-1]); up=true; } else if(up&&!su){ up=false; } }
      if(y<h-1){ const idd=id(x,y+1); const sd=same(d[idd],d[idd+1],d[idd+2],d[idd+3]); if(!dn&&sd){ st.push([x,y+1]); dn=true; } else if(dn&&!sd){ dn=false; } }
      x++;
    }
  }
  const rect={x:minx,y:miny,w:maxx-minx+1,h:maxy-miny+1}; const before=bctx.getImageData(rect.x,rect.y,rect.w,rect.h); bctx.putImageData(img,0,0); const after=bctx.getImageData(rect.x,rect.y,rect.w,rect.h); return {rect,before,after}; }
function makeBucket(store){ return { id:'bucket', cursor:'pointer', onPointerDown(ctx,ev,eng){ const h=store.getState().primaryColor; const r=parseInt(h.slice(1,3),16), g=parseInt(h.slice(3,5),16), b=parseInt(h.slice(5,7),16); const p=floodFillBctx(Math.floor(ev.img.x),Math.floor(ev.img.y),[r,g,b,255],16); if(p) eng.history.pushPatch(p); }, onPointerMove(){}, onPointerUp(){} }; }
function makeShape(kind,store){ let drawing=false,start=null,lastPreview=null; return {
  id:kind, cursor:'crosshair', previewRect:null,
  onPointerDown(ctx,ev,eng){ eng.clearSelection(); drawing=true; start={...ev.img}; lastPreview=null; },
  onPointerMove(ctx,ev,eng){ if(!drawing) return; const cur={...ev.img}; const s=store.getState();
    const x1=Math.min(start.x,cur.x), y1=Math.min(start.y,cur.y); let w=Math.max(1,Math.abs(cur.x-start.x)), h=Math.max(1,Math.abs(cur.y-start.y));
    if(ev.shift){ if(kind==='line'){ const dx=cur.x-start.x, dy=cur.y-start.y; const a=Math.atan2(dy,dx); const ang=Math.round(a/(Math.PI/4))*(Math.PI/4); const len=Math.hypot(dx,dy); cur.x=start.x+Math.cos(ang)*len; cur.y=start.y+Math.sin(ang)*len; } else { const m=Math.max(w,h); w=h=m; } }
    this.previewRect=(kind==='line')?{x:Math.min(start.x,cur.x),y:Math.min(start.y,cur.y),w:Math.abs(cur.x-start.x),h:Math.abs(cur.y-start.y)}:{x:Math.floor(x1),y:Math.floor(y1),w:Math.floor(w),h:Math.floor(h)};
    lastPreview={start,cur,shift:ev.shift,state:{...s}};
  },
  onPointerUp(ctx,ev,eng){ if(!drawing) return; drawing=false; if(!lastPreview){ this.previewRect=null; return; }
    const {start:s,cur,state}=lastPreview; 
    const strokeColor=state.primaryColor, fillColor=state.secondaryColor; const lineWidth=state.brushSize, fillOn=state.fillOn;
    ctx.save(); ctx.imageSmoothingEnabled=store.getState().antialias; ctx.lineWidth=lineWidth; ctx.strokeStyle=strokeColor; ctx.fillStyle=fillColor;
    if(kind==='line'){ ctx.beginPath(); ctx.moveTo(s.x+0.5, s.y+0.5); ctx.lineTo(cur.x+0.5, cur.y+0.5); ctx.stroke();
      eng.expandPendingRectByRect(Math.min(s.x,cur.x)-lineWidth, Math.min(s.y,cur.y)-lineWidth, Math.abs(cur.x-s.x)+lineWidth*2, Math.abs(cur.y-s.y)+lineWidth*2); }
    else if(kind==='rect'){ const x=Math.min(s.x,cur.x), y=Math.min(s.y,cur.y), w=Math.abs(cur.x-s.x), h=Math.abs(cur.y-s.y); if(fillOn) ctx.fillRect(x,y,w,h); ctx.strokeRect(x+0.5,y+0.5,w,h); eng.expandPendingRectByRect(x-lineWidth,y-lineWidth,w+lineWidth*2,h+lineWidth*2); }
    else if(kind==='ellipse'){ const cx=(s.x+cur.x)/2, cy=(s.y+cur.y)/2, rx=Math.abs(cur.x-s.x)/2, ry=Math.abs(cur.y-s.y)/2; ctx.beginPath(); drawEllipsePath(ctx,cx,cy,rx,ry); if(fillOn) ctx.fill(); ctx.stroke(); eng.expandPendingRectByRect(cx-rx-lineWidth, cy-ry-lineWidth, rx*2+lineWidth*2, ry*2+lineWidth*2); }
    ctx.restore(); this.previewRect=null; }
}; }
function drawEllipsePath(ctx,cx,cy,rx,ry){ const k=0.5522847498307936, ox=rx*k, oy=ry*k; ctx.moveTo(cx+rx,cy); ctx.bezierCurveTo(cx+rx,cy-oy, cx+ox,cy-ry, cx,cy-ry); ctx.bezierCurveTo(cx-ox,cy-ry, cx-rx,cy-oy, cx-rx,cy); ctx.bezierCurveTo(cx-rx,cy+oy, cx-ox,cy+ry, cx,cy+ry); ctx.bezierCurveTo(cx+ox,cy+ry, cx+rx,cy+oy, cx+rx,cy); }

function makeQuadratic(store){
  let stage=0,p0=null,p1=null,p2=null; return {
    id:'quad',cursor:'crosshair',previewRect:null,
    onPointerDown(ctx,ev,eng){
      if(stage===0){ p0={...ev.img}; stage=1; }
      else if(stage===1){ p2={...ev.img}; p1={x:(p0.x+p2.x)/2,y:(p0.y+p2.y)/2}; stage=2; }
      else if(stage===2){ const s=store.getState(); ctx.save(); ctx.lineWidth=s.brushSize; ctx.strokeStyle=s.primaryColor; ctx.beginPath(); ctx.moveTo(p0.x+0.5,p0.y+0.5); ctx.quadraticCurveTo(p1.x+0.5,p1.y+0.5,p2.x+0.5,p2.y+0.5); ctx.stroke(); ctx.restore(); const minX=Math.min(p0.x,p1.x,p2.x), minY=Math.min(p0.y,p1.y,p2.y), maxX=Math.max(p0.x,p1.x,p2.x), maxY=Math.max(p0.y,p1.y,p2.y); eng.expandPendingRectByRect(minX-s.brushSize,minY-s.brushSize,maxX-minX+s.brushSize*2,maxY-minY+s.brushSize*2); stage=0; this.previewRect=null; }
    },
    onPointerMove(ctx,ev){ if(stage===2){ p1={...ev.img}; } },
    onPointerUp(){},
    drawPreview(octx){ if(stage===2){ const s=store.getState(); octx.save(); octx.lineWidth=s.brushSize; octx.strokeStyle=s.primaryColor; octx.beginPath(); octx.moveTo(p0.x+0.5,p0.y+0.5); octx.quadraticCurveTo(p1.x+0.5,p1.y+0.5,p2.x+0.5,p2.y+0.5); octx.stroke(); octx.restore(); } }
  }; }

function makeCubic(store){
  let stage=0,p0=null,p1=null,p2=null,p3=null; return {
    id:'cubic',cursor:'crosshair',previewRect:null,
    onPointerDown(ctx,ev,eng){
      if(stage===0){ p0={...ev.img}; stage=1; }
      else if(stage===1){ p1={...ev.img}; stage=2; }
      else if(stage===2){ p2={...ev.img}; stage=3; }
      else if(stage===3){
        p3={...ev.img};
        const s=store.getState();
        ctx.save();
        ctx.lineWidth=s.brushSize;
        ctx.strokeStyle=s.primaryColor;
        ctx.beginPath();
        ctx.moveTo(p0.x+0.5,p0.y+0.5);
        ctx.bezierCurveTo(p1.x+0.5,p1.y+0.5,p2.x+0.5,p2.y+0.5,p3.x+0.5,p3.y+0.5);
        ctx.stroke();
        ctx.restore();
        const minX=Math.min(p0.x,p1.x,p2.x,p3.x), minY=Math.min(p0.y,p1.y,p2.y,p3.y), maxX=Math.max(p0.x,p1.x,p2.x,p3.x), maxY=Math.max(p0.y,p1.y,p2.y,p3.y);
        eng.expandPendingRectByRect(minX-s.brushSize,minY-s.brushSize,maxX-minX+s.brushSize*2,maxY-minY+s.brushSize*2);
        stage=0; this.previewRect=null;
      }
    },
    onPointerMove(ctx,ev){
      if(stage===1){ p1={...ev.img}; }
      else if(stage===2){ p2={...ev.img}; }
      else if(stage===3){ p3={...ev.img}; }
    },
    onPointerUp(){},
    drawPreview(octx){
      const s=store.getState();
      octx.save();
      octx.lineWidth=s.brushSize;
      octx.strokeStyle=s.primaryColor;
      if(stage===1 && p0 && p1){
        octx.beginPath();
        octx.moveTo(p0.x+0.5,p0.y+0.5);
        octx.lineTo(p1.x+0.5,p1.y+0.5);
        octx.stroke();
      } else if(stage===2 && p0 && p1 && p2){
        octx.beginPath();
        octx.moveTo(p0.x+0.5,p0.y+0.5);
        octx.lineTo(p1.x+0.5,p1.y+0.5);
        octx.lineTo(p2.x+0.5,p2.y+0.5);
        octx.stroke();
      } else if(stage===3 && p0 && p1 && p2 && p3){
        octx.beginPath();
        octx.moveTo(p0.x+0.5,p0.y+0.5);
        octx.bezierCurveTo(p1.x+0.5,p1.y+0.5,p2.x+0.5,p2.y+0.5,p3.x+0.5,p3.y+0.5);
        octx.stroke();
      }
      octx.restore();
    }
  }; }

function makeArc(store){
  let stage=0,cx=0,cy=0,r=0,start=0,end=0; return {
    id:'arc',cursor:'crosshair',previewRect:null,
    onPointerDown(ctx,ev,eng){
      if(stage===0){ cx=ev.img.x; cy=ev.img.y; stage=1; }
      else if(stage===1){ r=Math.hypot(ev.img.x-cx, ev.img.y-cy); start=Math.atan2(ev.img.y-cy, ev.img.x-cx); end=start; stage=2; }
      else if(stage===2){ const s=store.getState(); ctx.save(); ctx.lineWidth=s.brushSize; ctx.strokeStyle=s.primaryColor; ctx.beginPath(); ctx.arc(cx,cy,r,start,end); ctx.stroke(); ctx.restore(); const minX=cx-r, minY=cy-r; eng.expandPendingRectByRect(minX-s.brushSize,minY-s.brushSize,r*2+s.brushSize*2,r*2+s.brushSize*2); stage=0; }
    },
    onPointerMove(ctx,ev){ if(stage===2){ end=Math.atan2(ev.img.y-cy, ev.img.x-cx); } },
    onPointerUp(){},
    drawPreview(octx){ if(stage===2){ const s=store.getState(); octx.save(); octx.lineWidth=s.brushSize; octx.strokeStyle=s.primaryColor; octx.beginPath(); octx.arc(cx,cy,r,start,end); octx.stroke(); octx.restore(); } }
  }; }

function makeSector(store){
  let stage=0,cx=0,cy=0,r=0,start=0,end=0; return {
    id:'sector',cursor:'crosshair',previewRect:null,
    onPointerDown(ctx,ev,eng){
      if(stage===0){ cx=ev.img.x; cy=ev.img.y; stage=1; }
      else if(stage===1){ r=Math.hypot(ev.img.x-cx, ev.img.y-cy); start=Math.atan2(ev.img.y-cy, ev.img.x-cx); end=start; stage=2; }
      else if(stage===2){ const s=store.getState(); ctx.save(); ctx.lineWidth=s.brushSize; ctx.fillStyle=store.getState().fillOn?s.secondaryColor:'transparent'; ctx.strokeStyle=s.primaryColor; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,start,end); ctx.closePath(); if(store.getState().fillOn) ctx.fill(); ctx.stroke(); ctx.restore(); eng.expandPendingRectByRect(cx-r-s.brushSize,cy-r-s.brushSize,r*2+s.brushSize*2,r*2+s.brushSize*2); stage=0; }
    },
    onPointerMove(ctx,ev){ if(stage===2){ end=Math.atan2(ev.img.y-cy, ev.img.x-cx); } },
    onPointerUp(){},
    drawPreview(octx){ if(stage===2){ const s=store.getState(); octx.save(); octx.lineWidth=s.brushSize; octx.strokeStyle=s.primaryColor; octx.beginPath(); octx.moveTo(cx,cy); octx.arc(cx,cy,r,start,end); octx.closePath(); octx.stroke(); octx.restore(); } }
  }; }

function catmullRom(p0,p1,p2,p3,t){ const t2=t*t,t3=t2*t; return { x:0.5*((2*p1.x)+(-p0.x+p2.x)*t+(2*p0.x-5*p1.x+4*p2.x-p3.x)*t2+(-p0.x+3*p1.x-3*p2.x+p3.x)*t3), y:0.5*((2*p1.y)+(-p0.y+p2.y)*t+(2*p0.y-5*p1.y+4*p2.y-p3.y)*t2+(-p0.y+3*p1.y-3*p2.y+p3.y)*t3) }; }
function catmullRomSpline(pts,seg=16){ const out=[]; if(pts.length<2) return pts; for(let i=0;i<pts.length-1;i++){ const p0=pts[i-1]||pts[i],p1=pts[i],p2=pts[i+1],p3=pts[i+2]||p2; for(let j=0;j<=seg;j++){ const t=j/seg; out.push(catmullRom(p0,p1,p2,p3,t)); } } return out; }

function makeCatmull(store){ let pts=[]; function finalize(ctx,eng){ if(pts.length<4) return; const s=store.getState(); const cr=catmullRomSpline(pts); ctx.save(); ctx.lineWidth=s.brushSize; ctx.strokeStyle=s.primaryColor; ctx.beginPath(); ctx.moveTo(cr[0].x+0.5,cr[0].y+0.5); for(let i=1;i<cr.length;i++) ctx.lineTo(cr[i].x+0.5,cr[i].y+0.5); ctx.stroke(); ctx.restore(); let minX=cr[0].x,maxX=cr[0].x,minY=cr[0].y,maxY=cr[0].y; cr.forEach(p=>{minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y);}); eng.expandPendingRectByRect(minX-s.brushSize,minY-s.brushSize,maxX-minX+s.brushSize*2,maxY-minY+s.brushSize*2); eng.finishStrokeToHistory(); eng.requestRepaint(); pts=[]; }
  window.addEventListener('keydown',e=>{ if(e.key==='Enter') finalize(bctx,engine); });
  return { id:'catmull',cursor:'crosshair',previewRect:null,
    onPointerDown(ctx,ev){ pts.push({...ev.img}); },
    onPointerMove(){}, onPointerUp(){}, drawPreview(octx){ if(pts.length>1){ const cr=catmullRomSpline(pts); octx.save(); octx.lineWidth=store.getState().brushSize; octx.strokeStyle=store.getState().primaryColor; octx.beginPath(); octx.moveTo(cr[0].x+0.5,cr[0].y+0.5); for(let i=1;i<cr.length;i++) octx.lineTo(cr[i].x+0.5,cr[i].y+0.5); octx.stroke(); octx.restore(); } } };
}

function bspline(points,deg=3,seg=32){
  const n=points.length-1; if(n<deg) return points;
  const knots=[]; const m=n+deg+1;
  for(let i=0;i<=m;i++){
    if(i<=deg) knots.push(0);
    else if(i>=n+1) knots.push(n-deg+1);
    else knots.push(i-deg);
  }
  const out=[]; const start=knots[deg], end=knots[n+1];
  const step=(end-start)/seg;
  for(let s=0;s<=seg;s++){
    const u=start+s*step;
    let j=n; if(u<end){ for(let k=deg;k<=n;k++){ if(u>=knots[k]&&u<knots[k+1]){ j=k; break; } } }
    out.push(deBoor(deg,u,knots,points,j));
  }
  return out;
}
function deBoor(k,u,t,c,j){
  const d=[];
  for(let r=0;r<=k;r++) d[r]={...c[j-k+r]};
  for(let r=1;r<=k;r++){
    for(let i=k;i>=r;i--){
      const idx=j-k+i;
      const alpha=(u-t[idx])/(t[idx+k+1-r]-t[idx]);
      d[i]={ x:(1-alpha)*d[i-1].x+alpha*d[i].x,
             y:(1-alpha)*d[i-1].y+alpha*d[i].y };
    }
  }
  return d[k];
}

function makeBSpline(store){ let pts=[]; function finalize(ctx,eng){ if(pts.length<4) return; const s=store.getState(); const cr=bspline(pts); ctx.save(); ctx.lineWidth=s.brushSize; ctx.strokeStyle=s.primaryColor; ctx.beginPath(); ctx.moveTo(cr[0].x+0.5,cr[0].y+0.5); for(let i=1;i<cr.length;i++) ctx.lineTo(cr[i].x+0.5,cr[i].y+0.5); ctx.stroke(); ctx.restore(); let minX=cr[0].x,maxX=cr[0].x,minY=cr[0].y,maxY=cr[0].y; cr.forEach(p=>{minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y);}); eng.expandPendingRectByRect(minX-s.brushSize,minY-s.brushSize,maxX-minX+s.brushSize*2,maxY-minY+s.brushSize*2); eng.finishStrokeToHistory(); eng.requestRepaint(); pts=[]; }
  window.addEventListener('keydown',e=>{ if(e.key==='Enter') finalize(bctx,engine); });
  return { id:'bspline',cursor:'crosshair',previewRect:null,
    onPointerDown(ctx,ev){ pts.push({...ev.img}); },
    onPointerMove(){}, onPointerUp(){}, drawPreview(octx){ if(pts.length>1){ const cr=bspline(pts); octx.save(); octx.lineWidth=store.getState().brushSize; octx.strokeStyle=store.getState().primaryColor; octx.beginPath(); octx.moveTo(cr[0].x+0.5,cr[0].y+0.5); for(let i=1;i<cr.length;i++) octx.lineTo(cr[i].x+0.5,cr[i].y+0.5); octx.stroke(); octx.restore(); } } };
}

function nurbs(points,weights,deg=3,seg=32){ const n=points.length-1; const knots=[]; for(let i=0;i<=n+deg+1;i++) knots.push(i); function N(i,k,u){ if(k===0) return (u>=knots[i]&&u<knots[i+1])?1:0; const a=(u-knots[i])/(knots[i+k]-knots[i])||0; const b=(knots[i+k+1]-u)/(knots[i+k+1]-knots[i+1])||0; return a*N(i,k-1,u)+b*N(i+1,k-1,u); } const domain=[deg, knots.length-deg-1]; const out=[]; const step=(knots[domain[1]]-knots[domain[0]])/seg; for(let u=knots[domain[0]]; u<=knots[domain[1]]; u+=step){ let x=0,y=0,w=0; for(let i=0;i<=n;i++){ const b=N(i,deg,u)*weights[i]; x+=points[i].x*b; y+=points[i].y*b; w+=b; } out.push({x:x/w,y:y/w}); } return out; }

function makeNURBS(store){ let pts=[],ws=[]; function finalize(ctx,eng){ if(pts.length<4) return; const s=store.getState(); const cr=nurbs(pts,ws); ctx.save(); ctx.lineWidth=s.brushSize; ctx.strokeStyle=s.primaryColor; ctx.beginPath(); ctx.moveTo(cr[0].x+0.5,cr[0].y+0.5); for(let i=1;i<cr.length;i++) ctx.lineTo(cr[i].x+0.5,cr[i].y+0.5); ctx.stroke(); ctx.restore(); let minX=cr[0].x,maxX=cr[0].x,minY=cr[0].y,maxY=cr[0].y; cr.forEach(p=>{minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y);}); eng.expandPendingRectByRect(minX-s.brushSize,minY-s.brushSize,maxX-minX+s.brushSize*2,maxY-minY+s.brushSize*2); eng.finishStrokeToHistory(); eng.requestRepaint(); pts=[]; ws=[]; }
  window.addEventListener('keydown',e=>{ if(e.key==='Enter') finalize(bctx,engine); });
  return { id:'nurbs',cursor:'crosshair',previewRect:null,
    onPointerDown(ctx,ev){ pts.push({...ev.img}); const w=parseFloat(prompt('weight','1'))||1; ws.push(w); },
    onPointerMove(){}, onPointerUp(){}, drawPreview(octx){ if(pts.length>1){ const cr=nurbs(pts,ws); octx.save(); octx.lineWidth=store.getState().brushSize; octx.strokeStyle=store.getState().primaryColor; octx.beginPath(); octx.moveTo(cr[0].x+0.5,cr[0].y+0.5); for(let i=1;i<cr.length;i++) octx.lineTo(cr[i].x+0.5,cr[i].y+0.5); octx.stroke(); octx.restore(); } } };
}

function makeEllipse2(store){ let stage=0,cx=0,cy=0,rx=0,ry=0,rot=0; return { id:'ellipse2',cursor:'crosshair',previewRect:null,
  onPointerDown(ctx,ev,eng){ if(stage===0){ cx=ev.img.x; cy=ev.img.y; stage=1; }
    else if(stage===1){ rx=Math.abs(ev.img.x-cx); ry=Math.abs(ev.img.y-cy); rot=0; stage=2; }
    else if(stage===2){ const s=store.getState(); ctx.save(); ctx.lineWidth=s.brushSize; ctx.strokeStyle=s.primaryColor; if(store.getState().fillOn) ctx.fillStyle=s.secondaryColor; ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,rot,0,Math.PI*2); if(store.getState().fillOn) ctx.fill(); ctx.stroke(); ctx.restore(); eng.expandPendingRectByRect(cx-rx-s.brushSize,cy-ry-s.brushSize,rx*2+s.brushSize*2,ry*2+s.brushSize*2); stage=0; }
  },
  onPointerMove(ctx,ev){ if(stage===1){ rx=Math.abs(ev.img.x-cx); ry=Math.abs(ev.img.y-cy); } else if(stage===2){ rot=Math.atan2(ev.img.y-cy, ev.img.x-cx); } },
  onPointerUp(){},
  drawPreview(octx){ if(stage>0){ const s=store.getState(); octx.save(); octx.lineWidth=s.brushSize; octx.strokeStyle=s.primaryColor; octx.beginPath(); octx.ellipse(cx,cy,rx,ry,rot,0,Math.PI*2); octx.stroke(); octx.restore(); } }
}; }

function makeFreehand(store){ let pts=[],drawing=false; return { id:'freehand',cursor:'crosshair',previewRect:null,
  onPointerDown(ctx,ev){ drawing=true; pts=[{...ev.img}]; },
  onPointerMove(ctx,ev){ if(drawing) pts.push({...ev.img}); },
  onPointerUp(ctx,ev,eng){ if(!drawing) return; drawing=false; pts.push({...ev.img}); const s=store.getState(); const sm=catmullRomSpline(pts,8); ctx.save(); ctx.lineWidth=s.brushSize; ctx.strokeStyle=s.primaryColor; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.beginPath(); ctx.moveTo(sm[0].x+0.5,sm[0].y+0.5); for(let i=1;i<sm.length;i++) ctx.lineTo(sm[i].x+0.5,sm[i].y+0.5); ctx.stroke(); ctx.restore(); let minX=sm[0].x,maxX=sm[0].x,minY=sm[0].y,maxY=sm[0].y; sm.forEach(p=>{minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y);}); eng.expandPendingRectByRect(minX-s.brushSize,minY-s.brushSize,maxX-minX+s.brushSize*2,maxY-minY+s.brushSize*2); pts=[]; },
  drawPreview(octx){ if(drawing&&pts.length>1){ const sm=catmullRomSpline(pts,8); octx.save(); octx.lineWidth=store.getState().brushSize; octx.strokeStyle=store.getState().primaryColor; octx.beginPath(); octx.moveTo(sm[0].x+0.5,sm[0].y+0.5); for(let i=1;i<sm.length;i++) octx.lineTo(sm[i].x+0.5,sm[i].y+0.5); octx.stroke(); octx.restore(); } }
}; }
function makeSelectRect(){ let dragging=false,moving=false,start=null,grabOffset=null; return { id:'selectRect', cursor:'crosshair', previewRect:null,
  onPointerDown(ctx,ev,eng){ const sel=eng.selection;
    if(sel && eng.pointInRect(ev.img, sel.rect)){ if(!sel.floatCanvas){ const {x,y,w,h}=sel.rect; const img=bctx.getImageData(x,y,w,h); const fc=document.createElement('canvas'); fc.width=w; fc.height=h; fc.getContext('2d').putImageData(img,0,0); bctx.clearRect(x,y,w,h); eng.expandPendingRectByRect(x,y,w,h); sel.floatCanvas=fc; sel.pos={x,y}; }
      moving=true; grabOffset={dx:ev.img.x-sel.pos.x, dy:ev.img.y-sel.pos.y}; start=ev.img; return; }
    eng.clearSelection(); dragging=true; start=ev.img; this.previewRect={x:start.x,y:start.y,w:0,h:0}; },
  onPointerMove(ctx,ev,eng){ if(dragging){ const x1=Math.min(start.x,ev.img.x), y1=Math.min(start.y,ev.img.y), x2=Math.max(start.x,ev.img.x), y2=Math.max(start.y,ev.img.y); this.previewRect={x:Math.floor(x1),y:Math.floor(y1),w:Math.max(1,Math.floor(x2-x1)),h:Math.max(1,Math.floor(y2-y1))}; } else if(moving&&eng.selection){ eng.selection.pos={x:Math.floor(ev.img.x-grabOffset.dx), y:Math.floor(ev.img.y-grabOffset.dy)}; } },
  onPointerUp(ctx,ev,eng){ if(dragging){ dragging=false; const r=this.previewRect; if(r&&r.w>0&&r.h>0) eng.selection={rect:r,floatCanvas:null,pos:{x:r.x,y:r.y}}; this.previewRect=null; }
    else if(moving&&eng.selection){ moving=false; const sel=eng.selection; const old=sel.rect, neu={x:sel.pos.x,y:sel.pos.y,w:old.w,h:old.h}; eng.expandPendingRectByRect(old.x,old.y,old.w,old.h); eng.expandPendingRectByRect(neu.x,neu.y,neu.w,neu.h); bctx.drawImage(sel.floatCanvas,neu.x,neu.y); sel.rect=neu; sel.floatCanvas=null; }
    else { const sel=eng.selection; if(sel && !eng.pointInRect(ev.img, sel.rect)) eng.clearSelection(); } } }; }
let activeEditor=null;
// 置換：テキスト確定処理（Canvas用フォント＆二重スケール防止）
function cancelTextEditing(commit = false) {
  if (!activeEditor) return;

  if (commit) {
    // editorLayer は translate+scale 済 → left/top/サイズは「画像座標px」そのもの
    const x = Math.round(parseFloat(activeEditor.style.left) || 0);
    const y = Math.round(parseFloat(activeEditor.style.top)  || 0);
    const w = Math.ceil(activeEditor.offsetWidth);   // zoom で割らない
    const h = Math.ceil(activeEditor.offsetHeight);  // zoom で割らない

    const cs = getComputedStyle(activeEditor);
    const color      = cs.color;
    const fontSizePx = parseFloat(cs.fontSize) || 16;
    const fontWeight = cs.fontWeight || 'normal';
    const fontStyle  = cs.fontStyle  || 'normal';
    const fontFamily = cs.fontFamily || 'system-ui, sans-serif';
    const canvasFont = `${fontStyle} ${fontWeight} ${fontSizePx}px ${fontFamily}`;

    // line-height が 'normal' の場合は 1.4倍で代用
    let lineHeightPx = parseFloat(cs.lineHeight);
    if (isNaN(lineHeightPx)) lineHeightPx = Math.round(fontSizePx * 1.4);

    const paddingX = 6, paddingY = 4;
    const lines = activeEditor.innerText.replace(/\r/g, '').split('\n');

    bctx.save();
    bctx.font = canvasFont;         // Canvasは「xxpx ファミリ」形式のみ有効
    bctx.fillStyle = color;
    bctx.textBaseline = 'top';
    let ycur = y + paddingY;
    for (const line of lines) {
      bctx.fillText(line, x + paddingX, ycur);
      ycur += lineHeightPx;
    }
    bctx.restore();

    // 履歴（beginStrokeSnapshot は Textツール起動時に呼んでいる前提）
    engine.expandPendingRectByRect(x, y, w, h);
    engine.finishStrokeToHistory();
  }

  editorLayer.removeChild(activeEditor);
  activeEditor = null;
  editorLayer.style.pointerEvents = 'none'; // ★ここ！ camelCase
}

function makeTextTool(store){
  // 空contenteditableに即キャレットを出すヘルパ
  function focusEditable(el){
    el.focus();
    const r = document.createRange();
    r.selectNodeContents(el);
    r.collapse(true); // 先頭にキャレット
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(r);
  }

  return {
    id:'text', cursor:'text',
    onPointerDown(ctx,ev,eng){
      // 既存エディタ確定→新規開始
      cancelTextEditing(true);

      const left=Math.floor(ev.img.x), top=Math.floor(ev.img.y);
      const editor=document.createElement('div');
      editor.className='text-editor';
      editor.contentEditable='true';

      // 画像座標で配置（editorLayerはtranslate+scale済み）
      editor.style.left=left+'px';
      editor.style.top=top+'px';
      editor.style.minWidth='80px';

      // フォント設定
      const ff=document.getElementById('fontFamily').value;
      const fs=parseFloat(document.getElementById('fontSize').value||'24');
      editor.style.fontFamily=ff;
      editor.style.fontSize=fs+'px';
      editor.style.lineHeight=Math.round(fs*1.4)+'px';
      editor.style.color=store.getState().primaryColor;

      // ★ 空だとキャレットが出ないブラウザがあるので <br> を入れる
      editor.innerHTML = '<br>';

      editorLayer.appendChild(editor);
      activeEditor=editor;
      editorLayer.style.pointerEvents='auto';

      // Undo用スナップショット
      engine.beginStrokeSnapshot();

      // ★ pointerdown の処理が終わってからフォーカス/キャレットを当てる
      setTimeout(()=>{ focusEditable(editor); }, 0);

      // Enterで確定 / Escで取消（IMEはTextBox側が処理するのでここは単純に）
      const onKey=(e)=>{
        const isIme = e.isComposing || e.key === 'Process' || e.keyCode === 229;
        if(e.key==='Enter' && !e.shiftKey && !isIme){
          e.preventDefault(); cancelTextEditing(true); engine.requestRepaint(); cleanup();
        }else if(e.key==='Escape'){
          e.preventDefault(); cancelTextEditing(false); engine.requestRepaint(); cleanup();
        }
      };
      function cleanup(){ editor.removeEventListener('keydown', onKey); }
      editor.addEventListener('keydown', onKey);
    },
    onPointerMove(){}, onPointerUp(){}
  };
}



/* ===== init ===== */
const store=createStore({
  toolId:'pencil', primaryColor:'#000000', secondaryColor:'#ffffff', brushSize:4,
  fillOn:true, antialias:false
});
const vp=new Viewport();
const engine=new Engine(store,vp);

/* ===== UI bind ===== */
document.getElementById('brush').addEventListener('input', e=>store.set({brushSize:+e.target.value}));
document.getElementById('color').addEventListener('input', e=>store.set({primaryColor:e.target.value}));
document.getElementById('color2').addEventListener('input', e=>store.set({secondaryColor:e.target.value}));
document.getElementById('fillOn').addEventListener('change', e=>{
  store.set({ fillOn: e.target.checked });
});
document.getElementById('antialias').addEventListener('change', e=>{
  store.set({ antialias: e.target.checked });
  engine.requestRepaint();
});
document.getElementById('fontFamily').addEventListener('change', ()=>{ if(activeEditor) activeEditor.style.fontFamily=document.getElementById('fontFamily').value; });


document.getElementById('fontSize').addEventListener('change', ()=>{
  if(activeEditor){
    const fs = parseFloat(document.getElementById('fontSize').value || '24');
    activeEditor.style.fontSize = fs + 'px';
    activeEditor.style.lineHeight = Math.round(fs * 1.4) + 'px';
  }
});

document.getElementById('undo').addEventListener('click', ()=>{ cancelTextEditing(false); engine.undo(); });
document.getElementById('redo').addEventListener('click', ()=>{ cancelTextEditing(false); engine.redo(); });
document.getElementById('clear').addEventListener('click', ()=>{ 
    cancelTextEditing(false); 
    const before=bctx.getImageData(0,0,bmp.width,bmp.height);
    bctx.clearRect(0,0,bmp.width,bmp.height); 
    bctx.fillStyle='#ffffff'; 
    bctx.fillRect(0,0,bmp.width,bmp.height); 
    const after=bctx.getImageData(0,0,bmp.width,bmp.height);
    engine.history.pushPatch({ rect:{x:0,y:0,w:bmp.width,h:bmp.height}, before, after });
    engine.requestRepaint(); });
document.getElementById('fit').addEventListener('click', fitToScreen);
document.getElementById('actual').addEventListener('click', ()=>{ vp.zoom=1; vp.panX=0; vp.panY=0; engine.requestRepaint(); });

function selectTool(id){ cancelTextEditing(false); store.set({toolId:id}); document.querySelectorAll('.tool').forEach(b=>b.classList.toggle('active', b.dataset.tool===id)); engine.setTool(id); }
document.querySelectorAll('.tool').forEach(b=>b.addEventListener('click', ()=> selectTool(b.dataset.tool)));
function updateStatus(pos){ statusEl.textContent=`x:${Math.floor(pos.img.x)}, y:${Math.floor(pos.img.y)}  線:${store.getState().primaryColor} 塗:${document.getElementById('color2').value}  幅:${store.getState().brushSize}`; }

/* register tools */
engine.register(makeSelectRect());
engine.register(makePencil(store));
engine.register(makeEraser(store));
engine.register(makeEyedropper(store));
engine.register(makeBucket(store));
engine.register(makeShape('line', store));
engine.register(makeShape('rect', store));
engine.register(makeShape('ellipse', store));
engine.register(makeQuadratic(store));
engine.register(makeCubic(store));
engine.register(makeArc(store));
engine.register(makeSector(store));
engine.register(makeCatmull(store));
engine.register(makeBSpline(store));
engine.register(makeNURBS(store));
engine.register(makeEllipse2(store));
engine.register(makeFreehand(store));
engine.register(makeTextTool(store));
selectTool('pencil');

/* ===== IO: open/save ===== */
function initDocument(w=1280,h=720,bg='#ffffff'){ bmp.width=w; bmp.height=h; bctx.clearRect(0,0,w,h); bctx.fillStyle=bg; bctx.fillRect(0,0,w,h); fitToScreen(); }
document.getElementById('open').addEventListener('click', ()=>document.getElementById('fileInput').click());
document.getElementById('fileInput').addEventListener('change', e=>{ const f=e.target.files?.[0]; if(f) openImageFile(f); e.target.value=''; });
function openImageFile(file){ 
    const img=new Image(); 
    img.onload=()=>{ 
        const before=bctx.getImageData(0,0,bmp.width||1,bmp.height||1);
        bmp.width=img.naturalWidth;
        bmp.height=img.naturalHeight; 
        bctx.imageSmoothingEnabled=store.getState().antialias;
        bctx.clearRect(0,0,bmp.width,bmp.height);
        bctx.drawImage(img,0,0);
        const after=bctx.getImageData(0,0,bmp.width,bmp.height);
        //engine.history.pushPatch({x:0,y:0,w:Math.max(before.width,bmp.width),h:Math.max(before.height,bmp.height),before,after}); 
        engine.clearSelection();
        fitToScreen();
        engine.requestRepaint();
        saveSessionDebounced(); }; img.src=URL.createObjectURL(file); }
function downloadDataURL(url,name){ const a=document.createElement('a'); a.href=url; a.download=name; a.click(); }
document.getElementById('savePNG').addEventListener('click', ()=>{ const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height; c.getContext('2d').drawImage(bmp,0,0); downloadDataURL(c.toDataURL('image/png'),'image.png'); });
document.getElementById('saveJPG').addEventListener('click', ()=>{ const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height; const cctx=c.getContext('2d'); cctx.fillStyle='#ffffff'; cctx.fillRect(0,0,c.width,c.height); cctx.drawImage(bmp,0,0); downloadDataURL(c.toDataURL('image/jpeg',0.92),'image.jpg'); });
document.getElementById('saveWEBP').addEventListener('click', ()=>{ const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height; c.getContext('2d').drawImage(bmp,0,0); downloadDataURL(c.toDataURL('image/webp',0.92),'image.webp'); });

/* ===== Clipboard: Copy / Cut / Paste ===== */
document.getElementById('copyBtn').addEventListener('click', doCopy);
document.getElementById('cutBtn').addEventListener('click', doCut);
document.getElementById('pasteBtn').addEventListener('click', ()=>navigator.clipboard && navigator.clipboard.read && navigator.clipboard.read().then(handleClipboardItems).catch(()=>{/* ブラウザにより不可 */}));

async function doCopy(){
  const sel=engine.selection;
  let srcCanvas=null;
  if(sel){
    const {x,y,w,h}=sel.rect;
    const c=document.createElement('canvas'); c.width=w; c.height=h; const cctx=c.getContext('2d');
    if(sel.floatCanvas){ cctx.drawImage(sel.floatCanvas,0,0); } else { const img=bctx.getImageData(x,y,w,h); cctx.putImageData(img,0,0); }
    srcCanvas=c;
  } else {
    srcCanvas=bmp;
  }
  try{
    const blob=await new Promise(res=>srcCanvas.toBlob(res,'image/png'));
    if(!blob) throw new Error('blob null');
    await navigator.clipboard.write([new ClipboardItem({'image/png': blob})]);
    statusEl.textContent='コピー完了';
  }catch(e){
    statusEl.textContent='コピー不可（権限/ブラウザ制限）';
  }
}

async function doCut(){
  const sel=engine.selection; if(!sel){ statusEl.textContent='選択がないためカット不可'; return; }
  await doCopy();
  // クリア＆履歴
  const {x,y,w,h}=sel.rect; const before=bctx.getImageData(x,y,w,h);
  bctx.clearRect(x,y,w,h);
  const after=bctx.getImageData(x,y,w,h);
  engine.history.pushPatch({ rect:{x,y,w,h}, before, after });
  engine.clearSelection(); engine.requestRepaint(); saveSessionDebounced();
}

window.addEventListener('paste', async (e)=>{
  if(e.clipboardData){
    const items=[...e.clipboardData.items].filter(it=>it.type.startsWith('image/'));
    if(items.length){ e.preventDefault(); const file=items[0].getAsFile(); if(file) pasteImageFile(file); }
  } else if(navigator.clipboard && navigator.clipboard.read){
    try{ const items=await navigator.clipboard.read(); handleClipboardItems(items); }catch{}
  }
});
function handleClipboardItems(items){
  for(const item of items){
    for(const type of item.types){ if(type.startsWith('image/')){ item.getType(type).then(blob=>pasteImageFile(blob)); return; } }
  }
}
function pasteImageFile(file){
  const img=new Image();
  img.onload=()=>{
    const c=document.createElement('canvas'); c.width=img.naturalWidth; c.height=img.naturalHeight; c.getContext('2d').drawImage(img,0,0);
    // 中央にフロートで貼り付け
    const cx=bmp.width/2 - c.width/2, cy=bmp.height/2 - c.height/2;
    engine.selection={ rect:{x:Math.floor(cx),y:Math.floor(cy),w:c.width,h:c.height}, floatCanvas:c, pos:{x:Math.floor(cx), y:Math.floor(cy)} };
    engine.requestRepaint(); saveSessionDebounced();
  };
  img.src=URL.createObjectURL(file);
}

/* ===== Adjustments: UI + Preview + Apply ===== */
const adjPanel=document.getElementById('adjustPanel');
const adjBtn=document.getElementById('adjustBtn');
const brightnessEl=document.getElementById('adjBrightness');
const contrastEl=document.getElementById('adjContrast');
const saturationEl=document.getElementById('adjSaturation');
const hueEl=document.getElementById('adjHue');
const invertEl=document.getElementById('adjInvert');

adjBtn.addEventListener('click', ()=>{
  adjPanel.style.display = adjPanel.style.display==='none'||adjPanel.style.display==='' ? 'block' : 'none';
  if(adjPanel.style.display==='block'){ startFilterPreview(); } else { clearFilterPreview(); }
});
document.getElementById('adjReset').addEventListener('click', ()=>{ brightnessEl.value=0; contrastEl.value=0; saturationEl.value=0; hueEl.value=0; invertEl.checked=false; updateFilterPreview(); });
document.getElementById('adjCancel').addEventListener('click', ()=>{ clearFilterPreview(); adjPanel.style.display='none'; });
document.getElementById('adjApply').addEventListener('click', ()=>{ applyFilter(); adjPanel.style.display='none'; saveSessionDebounced(); });

[brightnessEl,contrastEl,saturationEl,hueEl].forEach(el=>el.addEventListener('input', updateFilterPreview));
invertEl.addEventListener('change', updateFilterPreview);

function startFilterPreview(){ updateFilterPreview(); }
function clearFilterPreview(){ engine.filterPreview=null; engine.requestRepaint(); }

function updateFilterPreview(){
  const sel=engine.selection;
  const params = {
    brightness: +brightnessEl.value, // [-100..100]
    contrast: +contrastEl.value,     // [-100..100]
    saturation: +saturationEl.value, // [-100..100]
    hue: +hueEl.value,               // [-180..180]
    invert: invertEl.checked ? 1 : 0
  };
  if(sel && sel.floatCanvas){
    const src=sel.floatCanvas;
    const can=applyFilterToCanvas(src, params);
    engine.filterPreview={canvas:can, x:sel.pos.x, y:sel.pos.y};
  } else if(sel){
    const {x,y,w,h}=sel.rect;
    const src=document.createElement('canvas'); src.width=w; src.height=h; src.getContext('2d').drawImage(bmp, x, y, w, h, 0, 0, w, h);
    const can=applyFilterToCanvas(src, params);
    engine.filterPreview={canvas:can, x, y};
  } else {
    const src=bmp;
    const can=applyFilterToCanvas(src, params);
    engine.filterPreview={canvas:can, x:0, y:0};
  }
  engine.requestRepaint();
}

function applyFilter(){
  if(!engine.filterPreview){ return; }
  const {canvas, x, y}=engine.filterPreview;
  if(engine.selection && engine.selection.floatCanvas){
    // フロートはそのまま置換（履歴は後で合成時）
    const sel=engine.selection;
    sel.floatCanvas = canvas; // 置き換え
    engine.filterPreview=null;
    engine.requestRepaint();
  } else {
    // before/after で履歴登録
    engine.beginStrokeSnapshot();
    const w=canvas.width, h=canvas.height;
    const before=bctx.getImageData(x,y,w,h);
    bctx.clearRect(x,y,w,h);
    bctx.drawImage(canvas, x, y);
    const after=bctx.getImageData(x,y,w,h);
    engine.history.pushPatch({ rect:{x,y,w,h}, before, after });
    engine.filterPreview=null;
    engine.requestRepaint();
  }
}

/* ===== Filter core (CPU) ===== */
function applyFilterToCanvas(srcCanvas, p){
  const w=srcCanvas.width, h=srcCanvas.height;
  const out=document.createElement('canvas'); out.width=w; out.height=h;
  const sctx=srcCanvas.getContext('2d'); const dctx=out.getContext('2d');
  const img=sctx.getImageData(0,0,w,h); const d=img.data;

  const b = p.brightness/100;               // add in [ -1 .. 1 ]
  const c = Math.tan((p.contrast/100)*Math.PI/4); // contrast factor
  const sat = 1 + p.saturation/100;         // multiply
  const hue = (p.hue||0) * Math.PI/180;     // radians
  const inv = p.invert ? 1 : 0;

  for(let i=0;i<d.length;i+=4){
    let r=d[i]/255, g=d[i+1]/255, bch=d[i+2]/255, a=d[i+3]/255;

    // brightness (add)
    r=r+b; g=g+b; bch=bch+b;

    // contrast around 0.5 -> remap to [-1..1] domain centered at 0
    r = 0.5 + c*(r-0.5); g = 0.5 + c*(g-0.5); bch = 0.5 + c*(bch-0.5);

    // to HSV for hue/sat
    let {h:sH, s:sS, v:sV} = rgb2hsv(clamp01(r), clamp01(g), clamp01(bch));
    sH = (sH + hue/(2*Math.PI)) % 1; if(sH<0) sH+=1;
    sS = clamp01(sS * sat);
    ({r,g,b:bch} = hsv2rgb(sH, sS, sV));

    // invert
    if(inv){ r=1-r; g=1-g; bch=1-bch; }

    d[i]=Math.round(clamp01(r)*255);
    d[i+1]=Math.round(clamp01(g)*255);
    d[i+2]=Math.round(clamp01(bch)*255);
    d[i+3]=Math.round(clamp01(a)*255);
  }
  dctx.putImageData(img,0,0);
  return out;
}
function clamp01(x){ return x<0?0:x>1?1:x; }
function rgb2hsv(r,g,b){
  const max=Math.max(r,g,b), min=Math.min(r,g,b); const d=max-min;
  let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h/=6; if(h<0) h+=1; }
  const s=max===0?0:d/max; const v=max;
  return {h,s,v};
}
function hsv2rgb(h,s,v){
  const i=Math.floor(h*6), f=h*6-i, p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
  switch(i%6){
    case 0: return {r:v,g:t,b:p};
    case 1: return {r:q,g:v,b:p};
    case 2: return {r:p,g:v,b:t};
    case 3: return {r:p,g:q,b:v};
    case 4: return {r:t,g:p,b:v};
    case 5: return {r:v,g:p,b:q};
  }
}

/* ===== Session (IndexedDB): autosave / restore ===== */
const DB_NAME='paintdb', STORE='kv', KEY='autosave';
function openDB(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>{ r.result.createObjectStore(STORE); }; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function saveSession(){
  try{
    const db=await openDB(); const tx=db.transaction(STORE,'readwrite'); const store=tx.objectStore(STORE);
    const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height; c.getContext('2d').drawImage(bmp,0,0);
    const dataURL=c.toDataURL('image/png');
    store.put({ dataURL, width:bmp.width, height:bmp.height, ts:Date.now() }, KEY);
    await tx.complete;
    autosaveBadge.textContent='AutoSave: ' + nowFmt();
  }catch(e){ autosaveBadge.textContent='AutoSave: 失敗'; }
}
let saveTimer=null;
function saveSessionDebounced(){ clearTimeout(saveTimer); saveTimer=setTimeout(saveSession, 800); }
async function loadSession(){
  try{
    const db=await openDB(); const tx=db.transaction(STORE,'readonly'); const store=tx.objectStore(STORE);
    const data=await new Promise((res,rej)=>{ const g=store.get(KEY); g.onsuccess=()=>res(g.result); g.onerror=()=>rej(g.error); });
    if(data && data.dataURL){
      if(confirm('前回の作業を復元しますか？')){
        const img=new Image(); img.onload=()=>{ bmp.width=data.width; bmp.height=data.height; bctx.clearRect(0,0,bmp.width,bmp.height); bctx.drawImage(img,0,0); fitToScreen(); engine.requestRepaint(); autosaveBadge.textContent='Restored: ' + nowFmt(); }; img.src=data.dataURL;
      }
    }
  }catch(e){ /* 無視 */ }
}
window.addEventListener('beforeunload', ()=>{ saveSession(); });
setInterval(saveSession, 15000); // 15秒ごとに自動保存

/* ===== fit / resize / boot ===== */
function fitToScreen(){ const r=stage.getBoundingClientRect(); const zx=r.width/bmp.width, zy=r.height/bmp.height; vp.zoom=Math.min(zx,zy); const c={x:bmp.width/2,y:bmp.height/2}; const scr=vp.imageToScreen(c.x,c.y); vp.panX+=(r.width/2 - scr.x); vp.panY+=(r.height/2 - scr.y); engine.requestRepaint(); }
const ro=new ResizeObserver(()=>engine.requestRepaint()); ro.observe(stage);

initDocument(1280, 720, '#ffffff');
engine.requestRepaint();
loadSession();
</script>
</body>
</html>
